= Bases de Datos I: Trabajo Práctico 2
Liz Moreno López <lilita.moreno@hotmail.com>; Micaela Vera <micavera2010@hotmail.com>; Verónica Juarez <veronicajuarez01@hotmail.com>
{docdate}. Docentes Hernán Rondelli y Mariano Trigila (COM-01)
:numbered:
:source-highlighter: highlight.js
:tabsize: 4

El presente documento consiste en describir la aplicación CLI realizada en Go siguiendo el diseño de datos relativo a operaciones de tarjetas de crédito. Dicha aplicación permitirá que el usuario pueda realizar las siguientes acciones:

- Autorización de la compra.
- Generación de la factura.
- Alerta a los clientes.


== Introducción

Las tarjetas no permiten a los usuarios financiar una compra en cuotas,
todo se realiza en un solo pago. Una persona puede tener más de una
tarjeta pero no deben existir extensiones de la misma. Las tarjetas
podrán estar expiradas en su fecha de vencimiento.

Las tarjetas tendrán consumos que deben surgir a partir de las compras
que se realicen en los distintos comercios.  También, nos interesan los
datos de los clientes, de las tarjetas de crédito con sus vencimientos y
límites, entre otros. 

A partir de los datos de una compra, se puede aceptar o rechazar dicha
compra. Se debe considerar distintos factores para la autorización de la
compra; debe existir el número de la tarjeta y corresponder a alguna
tarjeta vigente, el código de seguridad tiene que ser el correcto, el
monto total de las compras pendientes de pago más la compra a realizar
no debe superar el límite de compra de la tarjeta, por último, la
tarjeta no debe estar vencida ni suspendida.

Para cada nuevo consumo se deben guardar los datos de una factura con el
nombre y apellido, dirección, número de tarjeta, período de la factura,
fecha de vencimiento, todas las compras del período, y total a pagar.

Por último, se deben generar alertas por posibles fraudes. Existe un
Call Center que ante cada alerta generada automáticamente realiza un
llamado telefónico al cliente, indicándole la alerta detectada y
verifica si se trató de un fraude ó no.  Se debe tener en cuenta para
las alertas:

- Si una tarjeta registra dos compras en un lapso menor de un minuto en comercios distintos ubicados en el mismo código postal.
- Si una tarjeta registra dos compras en un lapso menor de 5 minutos en comercios con diferentes códigos postales.
- Si una tarjeta registra dos rechazos por exceso de límite en el mismo día, la tarjeta tiene que ser suspendida preventivamente.


== Descripción

En este apartado explicaremos las dificultades que tuvimos a lo largo de
la realización del trabajo práctico. Al principio, la ejecucion de las funciones nos resultó un poco tediosa, ya que tuvimos problemas co...........


Pensar lo de la ejecución en un determinado tiempo


En esta sección pueden incluirse las dificultades que tuvieron, las
soluciones encontradas, y las decisiones que fueron tomando a lo largo
del trabajo práctico.

También, se debe incluir una descripción general del programa—cómo
funciona.

*(Longitud: 3–5 párrafos)*



== 1.0Implementación



== 1.1 Go Database 
    Realizamos la creación de la database de la siguiente manera:

[source,sql]
----
func CrearDB() {
	db, err := sql.Open("postgres", "user = postgres dbname = postgres sslmode=disable")
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	//Exec para crear la DB tp2
	_, err = db.Exec(`create database tp2;`)

}
----
 
== 1.2 Go Creación de tablas

[source,sql]
----
func CrearTablas(db *sql.DB) {
	_, err := db.Exec(`create table cliente(
	nrocliente integer,
	nombre     varchar(64),
	apellido   varchar(64),
	domicilio  varchar(64),
	telefono   char(12)
);
create table tarjeta(
	nrotarjeta   char(12),
	nrocliente   integer,
	validadesde  char(6), --e.g 201106
	validahasta  char(6),
	codseguridad char(4),
	limitecompra decimal(8,2),
	estado       char(10) --'vigente', 'suspendida', 'anulada'
);
create table comercio(
	nrocomercio  integer,
	nombre       varchar(64),
	domicilio    varchar(64),
	codigopostal char(8),
	telefono     char(12)
);
create table compra(
	nrooperacion integer,
	nrotarjeta   char(16),
	nrocomercio  integer,
	fecha        timestamp,
	monto        decimal(7,2),
	pagado       boolean
);
create table rechazo(
	nrorechazo  integer,
	nrotarjeta  char(16),
	nrocomercio integer,
	fecha       timestamp,
	monto       decimal(7,2),
	motivo      varchar(64)
);
create table cierre(
	anio         integer,
	mes         integer,
	terminacion integer,
	fechainicio date,
	fechavto    date
);
create table cabecera(
	nroresumen  integer,
	nombre     varchar(64),
	apellido   varchar(64),
	domicilio  varchar(64),
	nrotarjeta char(16),
	desde      date,
	hasta      date,
	vence      date,
	total      decimal(8,2)
);
create table detalle(
	nroresumen      integer,
	nrolinea        integer,
	fecha           date,
	nombrecomercio  varchar(64),
	monto           decimal(7,2)
);
create table alerta(
	nroalerta   integer,
	nrotarjeta  char(16),
	fecha       timestamp,
	nrorechazo  integer,
	codalerta   integer, --0:rechazo, 1:compra 1min, 5:compra 5min, 32:límite
	descripcion  varchar(64)
);
create table consumo(
	nrotarjeta 	char(16),
	codseguridad	char(4),
	nrocomercio 	integer,
	monto        	decimal(7,2)
);`)
	if err != nil {
		log.Fatal(err)
	}

}

func AgregarPKs(db *sql.DB) {
	_, err := db.Exec(`alter table tarjeta  add constraint tarjeta_pk   primary key (nrotarjeta);
		alter table comercio add constraint comercio_pk  primary key (nrocomercio);
		alter table compra   add constraint compra_pk    primary key (nrooperacion);
		alter table rechazo  add constraint rechazo_pk   primary key (nrorechazo);
		alter table cierre   add constraint cierre_pk    primary key (anio,mes,terminacion);
		alter table cierre   add constraint cierre_pk    primary key (mes,terminacion);
		alter table cabecera add constraint cabecera_pk  primary key (nroresumen);
		alter table detalle  add constraint detalle_pk   primary key (nroresumen,nrolinea);
		alter table alerta   add constraint alerta_pk    primary key (nroalerta);`)

	if err != nil {
		log.Fatal(err)
	}

}
----







En esta apartado explicaremos la implementación de los stored procedures realizados como los respectivos triggers.

=== Autorización de la compra
La *autorización de la compra* consiste en recibir los datos de la tarjeta, es decir, el número de dicha tarjeta y su código de seguridad, el número del comercio y el monto de dicho consumo. 

Para esto, realizamos la función *autorizar_compra* que toma como los parámetros los datos nombrados anteriormente, cuyo valor de retorno será un boolean. 
Si todos estos datos son correctos, se procederá a autorizar dicha compra, por esto la función retornara _true_. En caso de que algún dato sea inválido, devolverá _false_.

El procedimiento antes de autorizar dicha compra debe cumplir una serie de elementos:
    
    - El número de la tarjeta debe ser existente, y corresponder a alguna tarjeta vigente.
    En caso de que no cumpla, se debe cargar los datos en la tabla rechazo con el mensaje *?tarjeta no válida o no vigente*.

    - El código de seguridad debe ser correcto. 
    En caso de que no cumpla, se debe cargar los datos en la tabla rechazo con el mensaje *?código de seguridad inválido*.

    - El monto total de compras pendientes de pago más la compra a realizar no debe superar el límite de compra de la tarjeta.
    En caso de que no cumpla, se debe cargar los datos en la tabla rechazo con el mensaje *?supera límite de tarjeta*.

    - La tarjeta no debe estar vencida. 
    En caso de que no cumpla, se debe cargar los datos en la tabla rechazo con el mensaje *?plazo de vigencia expirado*.

    - La tarjeta no debe estar suspendida. En caso de que no cumpla ,se debe cargar los datos en la tabla rechazo con el mensaje *?la tarjeta se encuentra suspendida*.

Por esto, como se nombró anteriormente si al menos uno de los parámetros es inválido se procederá a insertar los datos de la compra en la tabla *rechazo* donde se ingresará el número de la tarjeta, el número de comercio, el monto, la fecha y el respectivo mensaje del motivo del rechazo de dicha compra. 


La tabla *rechazo* al insertar los datos posee el siguiente formato:
-
[source,sql]
----
insert into rechazo values (default,nrocomercio, nrocomercio, fecha, monto, motivo)
----

En cambio, si dicha compra está autorizada, se procederá{} a insertar los datos correspondientes en la tabla *compra*.

La tabla *compra* al insertar los datos se sigue el siguiente formato:

[source,sql]
----
insert into compra values()
----

La función que nombramos anteriormente, cuyo nombre es *autorizacion_compra* posee el siguiente formato:

[source,sql]
----




----

=== Generación del resumen 
La *generación del resumen* consiste en tomar el numero del cliente y el periodo del año(año y mes) para asi insertar los datos correspondientes en las tablas *cabecera* y *detalle*. Donde en la respectiva tabla se insertaran el nombre, apellido, numero de tarjeta y direccion del cliente, el periodo del resumen, fecha de vencimiento , todas las compras realizadas en el periodo establecido y el total a pagar.



=== Alertas a clientes

Se debe generar alertas por posibles fraudes. Existe un Call Center que ante cada alerta generada automáticamente, realiza un llamado telefónico al cliente, indicándole la alerta detectada, y verifica
si se trató de un fraude ó no.
 
Como todo rechazo se debe ingresar automáticamente a la tabla de alertas. No puede haber ninguna demora para ingresar un rechazo en la tabla de alertas, se debe ingresar en el mismo instante en que se generó el rechazo.

Para asegurar esto, realizamos un trigger *generar_alerta()*, cuando se inserta los datos de un rechazo en la tabla *rechazo* se dispara el trigger y se guardan los respectivos datos en la tabla *alerta*.

En esta sección se incluye el código fuente correctamente formateado—y
comentado, si corresponde. Además, por cada fragmento de código
relevante—i.e. función, método, procedimiento—se debe dar una
descripción general, decir qué hace, y especificar los parámetros que
toma la función/método/procedimiento, junto con los valores que devuelve
ó modifica.

_No debería incluirse el código de librerías/frameworks que se
utilicen—a no ser que sea absolutamente necesario._

*(Longitud: lo que sea necesario)*



== Conclusiones

Aquí van algunas reflexiones acerca del proceso de desarrollo del
trabajo realizado, y de los resultados obtenidos. También se debe
incluir una conclusión final de producto terminado.

Pueden incluirse lecciones aprendidas durante el desarrollo del trabajo.

*(Longitud: 1–3 párrafos)*
